/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stream;


import org.apache.kafka.streams.KafkaStreams;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.StreamsConfig;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.KTable;
import org.apache.kafka.streams.kstream.Materialized;
import org.apache.kafka.streams.kstream.Produced;
import org.apache.kafka.streams.kstream.Serialized;
import org.apache.kafka.streams.kstream.WindowedSerdes;
import org.apache.kafka.streams.state.KeyValueStore;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import org.apache.kafka.common.serialization.Deserializer;
import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.serialization.Serializer;
import org.apache.kafka.common.utils.Bytes;
import org.apache.kafka.connect.json.JsonDeserializer;
import org.apache.kafka.connect.json.JsonSerializer;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.CountDownLatch;


public class App {
  
    public static void main(String[] args) {
        Properties props = new Properties();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, "streams-station");
        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:19094,localhost:29094,localhost:39094"); // 부트스트랩 서버는 카프카 클러스터에 접속하기 위한 초기 접점입니다.
        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass()); // 키의 기본 직렬화/역직렬화 클래스를 설정
        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass()); // 값의 기본 직렬화/역직렬화 클래스를 설정

        final Serializer<JsonNode> jsonNodeSerializer = new JsonSerializer();
        final Deserializer<JsonNode> jsonNodeDeserializer = new JsonDeserializer();
        final Serde<JsonNode> jsonNodeSerde = Serdes.serdeFrom(jsonNodeSerializer,jsonNodeDeserializer);

       // Create a StreamsBuilder object
        StreamsBuilder builder = new StreamsBuilder();


        // Create a KStream from the seoulRide topic
        KStream<String, JsonNode> busStationStream = builder.stream("dbserver1.seoulDB.busStation", Consumed.with(Serdes.String(), jsonNodeSerde));

        //pick schema and payload from the stream
        KStream<String, JsonNode> modifiedBusStationStream =busStationStream.mapValues(value -> {
            System.out.println("XCODE : "+value.get("payload").get("after").get("XCODE").toString());
            String dong =coordToAddr(value.get("payload").get("after").get("XCODE").toString(), 
                        value.get("payload").get("after").get("YCODE").toString());
            System.out.println("dong : "+dong);
            ObjectNode modifiedValue = ((ObjectNode) value.get("payload").get("after"));
            modifiedValue.put("dong", dong); // 새로운 컬럼 추가
       
            return modifiedValue;
        });
        
        modifiedBusStationStream.to("test", Produced.with(Serdes.String(), jsonNodeSerde));
        
       
       

        // Convert the KStream to a KTable using the id as the key
        //<키의 타입, 값의 타입> 순서
        // KTable<String, JsonNode> busStationKTable = busStationStream.groupByKey(Serialized.with(Serdes.String(), jsonNodeSerde))
        //                                                             .aggregate(null, null, null, null);
        // busStationKTable.toStream().to("test" );









        
        final Topology topology = builder.build();
        System.out.println(topology.describe());

        final KafkaStreams streams = new KafkaStreams(topology, props);
        final CountDownLatch latch = new CountDownLatch(1);// 이걸 통해서 만약 메인 스레드는 계속 대기하고 Ctrl+C가 입력되면 종료

        // Ctrl+C를 처리하기 위한 핸들러 추가
        Runtime.getRuntime().addShutdownHook(new Thread("streams-shutdown-hook") {
            @Override
            public void run() {
                streams.close();
                latch.countDown();
                System.out.println("topology terminated");
            }
        });

        try {
            streams.start();
            System.out.println("topology started");
            latch.await();
        } catch (Throwable e) {
            System.exit(1);
        }
        System.exit(0);
    }

  /**
      * 경위도 정보로 주소를 불러오는 메소드
      * @throws UnsupportedEncodingException 
      */
      public static String coordToAddr(String longitude, String latitude){
        String url = "https://dapi.kakao.com/v2/local/geo/coord2address.json?x="+longitude+"&y="+latitude;
        String addr = "";
        try{
          addr = getRegionAddress(getJSONData(url));
          //LOGGER.info(addr);
        }catch(Exception e){
          System.out.println("주소 api 요청 에러");
          e.printStackTrace();
        }
          return addr;
  
      }

    /**
      * REST API로 통신하여 받은 JSON형태의 데이터를 String으로 받아오는 메소드
      */
	private static String getJSONData(String apiUrl) throws Exception {
    	HttpURLConnection conn = null;
    	StringBuffer response = new StringBuffer();
    	 
    	//인증키 - KakaoAK하고 한 칸 띄워주셔야해요!
    	String auth = "KakaoAK " + "bcab2e30de8e43130afebdb594c04dd4";

    	//URL 설정
        URL url = new URL(apiUrl);
         
        conn = (HttpURLConnection) url.openConnection();
        
        //Request 형식 설정
        conn.setRequestMethod("GET");
        conn.setRequestProperty("X-Requested-With", "curl");
        conn.setRequestProperty("Authorization", auth);

        //request에 JSON data 준비
        conn.setDoOutput(true);
         
        //보내고 결과값 받기
        int responseCode = conn.getResponseCode();
        if (responseCode == 400) {
            System.out.println("400:: 해당 명령을 실행할 수 없음");
        } else if (responseCode == 401) {
            System.out.println("401:: Authorization가 잘못됨");
        } else if (responseCode == 500) {
            System.out.println("500:: 서버 에러, 문의 필요");
        } else { // 성공 후 응답 JSON 데이터받기
        	 
        	 Charset charset = Charset.forName("UTF-8");
             BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));
             
             String inputLine;
             while ((inputLine = br.readLine()) != null) {
             	response.append(inputLine); 
             } 
         }
         
         return response.toString();
    }
    
   

private static String getRegionAddress(String jsonString) {
    String value = "";

    try {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode = objectMapper.readTree(jsonString);

        JsonNode metaNode = rootNode.get("meta");
        long size = metaNode.get("total_count").asLong();

        if (size > 0) {
            JsonNode documentsNode = rootNode.get("documents");
            JsonNode subJobj = documentsNode.get(0);
            JsonNode roadAddress = subJobj.get("road_address");

            if (roadAddress == null) {
                JsonNode subsubJobj = subJobj.get("address");
                value = subsubJobj.get("address_name").asText();
            } else {
                value = roadAddress.get("address_name").asText();
            }

            if (value.equals("") || value == null) {
                subJobj = documentsNode.get(1);
                subJobj = subJobj.get("address");
                value = subJobj.get("address_name").asText();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }

    return value;
}
        /*
         * 초기값, 덧셈기, 뺄셈기입니다. 
         * 초기값은 키에 대한 값이 없을 때 사용되는 값입니다. 
         * 덧셈기는 새로운 레코드가 들어올 때 기존의 값에 더해주는 함수입니다. 
         * 뺄셈기는 기존의 레코드가 삭제될 때 기존의 값에서 빼주는 함수입니다. 
         */

        
        // Parse the array of strings into a map of key-value pairs
        // KStream<Long, Map<String, String>> parsedKStream = busStationSplitedStream.mapValues(value -> {
        //     Map<String, String> busStationMap = new HashMap<>();
        //     busStationMap.put("id", value[0]);
        //     busStationMap.put("bsst_ars_no", value[1]);
        //     busStationMap.put("bus_sta_nm", value[2]);
        //     busStationMap.put("X_CODE", value[3]);
        //     busStationMap.put("Y_CODE", value[4]);
        //     return busStationMap;
        // });
        
        

        // Create a KTable for busRoute
        // KTable<String, String> busRouteTable = seoulRideStream
        //     .groupBy((key, value) -> value.get("BUS_ROUTE_NO")) // Group by BUS_ROUTE_NO
        //     .aggregate(
        //         () -> "", // Initial value
        //         (key, value, aggregate) -> value.get("BUS_ROUTE_NM"), // Adder
        //         (key, value, aggregate) -> "", // Subtractor
        //         "busRouteStore" // State store name
        //     );

        // // Create a KTable for busType
        // KTable<String, String> busTypeTable = seoulRideStream
        //     .groupBy((key, value) -> value.get("BUS_ROUTE_NO")) // Group by BUS_ROUTE_NO
        //     .aggregate(
        //         () -> "", // Initial value
        //         (key, value, aggregate) -> value.get("MNTN_TYP_CD") + "," + value.get("MNTN_TYP_NM"), // Adder
        //         (key, value, aggregate) -> "", // Subtractor
        //         "busTypeStore" // State store name
        //     );

        // Create a KTable for rideInfo
        // KTable<String, String> rideInfoTable = seoulRideStream
        //     .groupBy((key, value) -> key) // Group by _pk
        //     .aggregate(
        //         () -> "", // Initial value
        //         (key, value, aggregate) -> value.get("USE_MON") + "," + value.get("STND_BSST_ID") + "," + value.get("TWENTY_TWO_RIDE_NUM") + "," + value.get("TWENTY_TWO_ALIGHT_NUM") + "," + value.get("TWENTY_THREE_RIDE_NUM") + "," + value.get("TWENTY_THREE_ALIGHT_NUM") + "," + value.get("WORK_DT"), // Adder
        //         (key, value, aggregate) -> "", // Subtractor
        //         "rideInfoStore" // State store name
        //     );

        // Write the KTables to different topics
        //busStationTable.to("busStationTopic");
        // busRouteTable.to("busRouteTopic");
        // busTypeTable.to("busTypeTopic");
        // rideInfoTable.to("rideInfoTopic");
    }


